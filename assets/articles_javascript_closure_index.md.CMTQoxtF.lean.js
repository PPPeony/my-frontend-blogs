import{_ as i,c as a,a0 as n,o as t}from"./chunks/framework.p2VkXzrt.js";const c=JSON.parse('{"title":"闭包","description":"","frontmatter":{},"headers":[],"relativePath":"articles/javascript/closure/index.md","filePath":"articles/javascript/closure/index.md"}'),e={name:"articles/javascript/closure/index.md"};function l(h,s,p,k,r,o){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h1><h3 id="_1-什么是闭包-什么是词法环境" tabindex="-1">1. 什么是闭包? 什么是词法环境？ <a class="header-anchor" href="#_1-什么是闭包-什么是词法环境" aria-label="Permalink to &quot;1. 什么是闭包? 什么是词法环境？&quot;">​</a></h3><blockquote><p>A <strong>closure</strong> is the combination of a function bundled together (enclosed) with references to its surrounding state (the <strong>lexical environment</strong>). In other words, a closure gives you access to an outer function&#39;s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.</p><p>A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.</p><p>A <strong>Lexical Environment</strong> is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code.</p></blockquote><p>翻译一下： 闭包就是一个函数和引用的变量（在该函数作用域之外声明的变量）的组合。</p><p><strong>示例1:</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Mozilla&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// name 是一个被 init 创建的局部变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> displayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // displayName() 是内部函数，一个闭包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用了父级作用中声明的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  displayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p><strong>示例2:</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largeData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> innerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largeData; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>问： 父函数中的变量c会在闭包内吗？</strong></p><p>答：在这个例子中，虽然变量<code>c</code>在父函数<code>outerFunction</code>中定义，但它并没有在闭包<code>innerFunction</code>中被引用或使用，所以它不会被包含在闭包的环境中。</p><p>闭包会“记住”它的创建环境中所有被引用的变量，即使这个环境已经不存在了。但是，如果一个变量在闭包中没有被引用，那么这个变量就不会被闭包“记住”，当父函数执行完毕后，这个变量就会被垃圾收集器回收。</p><p>所以，虽然<code>c</code>在<code>outerFunction</code>中定义，但它不会在闭包<code>innerFunction</code>中存在。如果你想让<code>c</code>在闭包中存在，你需要在<code>innerFunction</code>中引用它，如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largeData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> innerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largeData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个修改后的例子中，<code>c</code>在闭包<code>innerFunction</code>中被引用，所以它会被闭包“记住”，即使<code>outerFunction</code>执行完毕后，<code>c</code>也不会被垃圾收集器回收。</p><h3 id="_2-父函数返回了闭包-父函数执行完了-父函数的执行上下文会销毁吗" tabindex="-1">2. 父函数返回了闭包，父函数执行完了，父函数的执行上下文会销毁吗？ <a class="header-anchor" href="#_2-父函数返回了闭包-父函数执行完了-父函数的执行上下文会销毁吗" aria-label="Permalink to &quot;2. 父函数返回了闭包，父函数执行完了，父函数的执行上下文会销毁吗？&quot;">​</a></h3><p>在 JavaScript 中，当一个函数返回了一个闭包（也就是一个内部函数），那么这个内部函数会保留对其父函数作用域中的变量的引用。这就是所谓的 &quot;闭包&quot;。即使父函数已经执行完毕，这些变量仍然可以被内部函数访问，因为它们被内部函数的作用域链所引用。</p><p>所以，即使父函数的执行上下文已经从执行栈中弹出，但只要内部函数还在使用这些变量，这些变量就不会被垃圾回收机制回收，它们的值会被保留下来。</p><p>这就是为什么闭包可以 &quot;记住&quot; 它们被创建时的环境。这是 JavaScript 中非常强大的一个特性，但也需要注意，如果不正确地使用闭包，可能会导致内存泄漏。</p><h3 id="_3-闭包的作用" tabindex="-1">3. 闭包的作用 <a class="header-anchor" href="#_3-闭包的作用" aria-label="Permalink to &quot;3. 闭包的作用&quot;">​</a></h3><p>在JavaScript中，闭包是一种可以访问其自身作用域、外部函数作用域以及全局作用域变量的函数。闭包的主要作用有以下几点：</p><ol><li><strong>数据封装和私有化</strong>：闭包可以用来隐藏和保护内部状态，只暴露必要的接口。这是实现JavaScript模块模式的关键。</li><li><strong>创建数据的私有版本</strong>：每次函数被调用时，闭包都可以为每个函数创建私有的变量和方法。这对于实现工厂和构造函数非常有用。</li><li><strong>实现公有变量</strong>：闭包可以在函数之间共享变量，而不必将它们作为全局变量。</li><li><strong>记忆（缓存）</strong> ：闭包可以用于存储计算结果，以便在后续调用中重用，这种技术被称为记忆或缓存。</li></ol><h3 id="_4-参考" tabindex="-1">4. 参考 <a class="header-anchor" href="#_4-参考" aria-label="Permalink to &quot;4. 参考&quot;">​</a></h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></p>`,23)]))}const E=i(e,[["render",l]]);export{c as __pageData,E as default};
